!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):(e="undefined"!=typeof globalThis?globalThis:e||self).jsDocLite=t()}(this,(function(){"use strict";return{entryRegex:{function:/@(function|func|method)\s+([a-zA-Z_$][0-9a-zA-Z_$]*)/gm,constant:/@(const|constant|property)\s+{(\w+)}\s+([a-zA-Z_$][0-9a-zA-Z_$]*)/gm,module:/@(module|class)\s+([a-zA-Z_$][0-9a-zA-Z_$]*)/gm},tagRegex:{params:/@(param|arg|argument)\s+{([\s\S]*?)}\s+([a-zA-Z_$][0-9a-zA-Z_$]*)\s*-([\s\S]*?)(?=@|$)/g,returns:/@returns\s+{([\s\S]*?)}\s+([\s\S]*?)(?=@|$)/g,async:/@async/g,example:/@example\s+([\s\S]*?)(?=@|$)/g,see:/@(see|link|doc)\s+([\s\S]*?)(?=@|$)/g},jsdocRegex:/\/\*\*([\s\S]*?)\*\//g,async parseFromUrl(e){const t=await this.fetchJsContent(e);return this.parse(t)},parse(e){const t=e.match(this.jsdocRegex)||[],s={modules:{},constants:{},functions:{}};return t.forEach((e=>{const t=this.cleanCommentBlock(e),n=this.parseComment(t);n&&n.entryName&&(s[n.entryType+"s"][n.entryName]=n)})),s},parseComment(e){let t=null,s=null,n=null;const a=e.match(/^(.+?)(?=@|$)/s),r=a?a[0].trim():null;if(Object.entries(this.entryRegex).forEach((([a,r])=>{r.lastIndex=0;const c=r.exec(e);if(c)switch(s=a,a){case"constant":n=c[2],t=c[3];break;case"module":t=c[1];break;default:t=c[2]}})),!t)return null;const c={entryType:s,entryName:t,description:r,...n?{dataType:n}:{}};for(const[t,s]of Object.entries(this.tagRegex)){const n=[...e.matchAll(s)];if(n.length)switch(t){case"params":c[t]=n.map((e=>({type:e[2]?.trim(),name:e[3]?.trim(),description:e[4]?.trim()})));break;case"returns":c[t]=n.map((e=>({type:e[1]?.trim(),description:e[2]?.trim()})));break;case"async":c[t]=!0;break;case"link":c[t]=n[0][1].trim();break;default:c[t]=n.map((e=>e[1]?.trim()))}}return c},cleanCommentBlock:e=>e=(e=e.replace(/\/\*\*|\*\//g,"").trim()).replace(/^\s*\*+/gm,"").trim(),async fetchJsContent(e){const t=await fetch(e);if(!t.ok)throw new Error(`Failed to fetch JS content from ${e}`);return t.text()}}}));
